<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Invert Binary Tree — Visualization (LC 226)</title>
<style>
  :root{
    --bg:#f7fafc;
    --node-bg:#2563eb;
    --node-size:44px;
    --highlight:#f59e0b;
    --text:#111827;
  }
  body{font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);padding:18px;}
  h1{margin:0 0 12px 0;font-size:20px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
  button{padding:8px 12px;border-radius:8px;border:1px solid #cbd5e1;background:#fff;cursor:pointer}
  button:disabled{opacity:.45;cursor:not-allowed}
  pre#info{background:#fff;padding:10px;border:1px solid #e6e6e6;border-radius:8px;min-height:46px;white-space:pre-wrap;margin-bottom:12px}

  .tree-wrap{position:relative;border-radius:10px;padding:12px;background:linear-gradient(180deg,#ffffff,#fbfdff);box-shadow:0 4px 12px rgba(2,6,23,0.06);min-height:360px}
  svg#lines{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;overflow:visible}
  .tree-canvas{position:relative;width:100%;height:100%}

  .node-item{position:absolute;transform:translate(-50%,-50%);display:flex;flex-direction:column;align-items:center;pointer-events:auto}
  .node-bubble{width:var(--node-size);height:var(--node-size);border-radius:50%;background:var(--node-bg);color:#fff;display:flex;align-items:center;justify-content:center;font-weight:700;box-shadow:0 6px 18px rgba(37,99,235,0.12);transition:opacity .28s ease, transform .18s ease}
  .node-bubble.current{outline:4px solid var(--highlight);transform:scale(1.08)}
  .node-bubble.fading{opacity:0}
  .node-label{margin-top:6px;font-size:12px;color:#374151}
  line{stroke:#6b7280;stroke-width:2;stroke-linecap:round}

  @media (max-width:700px){:root{--node-size:36px}}
</style>
</head>
<body>
  <h1>LeetCode 226 — Invert Binary Tree</h1>

  <div class="controls">
    <button id="prevBtn">Prev</button>
    <button id="nextBtn">Next</button>
    <button id="runBtn">Run to End</button>
    <button id="resetBtn">Reset</button>
  </div>

  <pre id="info">Step info will appear here</pre>

  <div class="tree-wrap" id="treeWrap">
    <svg id="lines" xmlns="http://www.w3.org/2000/svg"></svg>
    <div id="canvas" class="tree-canvas"></div>
  </div>

<script>
(() => {
  // ---------------- Example tree ----------------
  const EXAMPLE = {
    val: 4,
    left: { val:2, left:{val:1}, right:{val:3} },
    right: { val:7, left:{val:6}, right:{val:9} }
  };

  // ---------------- State ----------------
  let steps = [];     // sequence of {action: 'visit'|'swap', id, val}
  let stepIndex = 0;

  // ---------------- Helpers: clone with consistent ids ----------------
  let _idCounter = 1;
  function cloneWithId(node){
    if(!node) return null;
    const obj = { id: (_idCounter++), val: node.val, left: cloneWithId(node.left), right: cloneWithId(node.right) };
    return obj;
  }

  // create single canonical tree (used both for steps and rendering)
  const exampleRoot = cloneWithId(EXAMPLE);

  // build steps (visit, then recurse left/right, then swap) on same tree instance
  function buildSteps(root){
    if(!root) return;
    steps.push({ action:'visit', id: root.id, val: root.val });
    buildSteps(root.left);
    buildSteps(root.right);
    steps.push({ action:'swap', id: root.id, val: root.val });
  }
  buildSteps(exampleRoot);

  // ---------------- DOM refs ----------------
  const wrap = document.getElementById('treeWrap');
  const canvas = document.getElementById('canvas');
  const svg = document.getElementById('lines');
  const infoEl = document.getElementById('info');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const runBtn = document.getElementById('runBtn');
  const resetBtn = document.getElementById('resetBtn');

  // ---------------- Layout: compute positions via inorder numbering (safe-guard visited) ----------------
  function computePositions(rootClone){
    const positions = new Map();
    const visited = new Set();
    let order = 0;
    function inorder(node, depth){
      if(!node || visited.has(node.id)) return;
      // visited set prevents cycles if present
      visited.add(node.id);
      inorder(node.left, depth+1);
      order++;
      const spacingX = 110; // horizontal spacing
      const x = order * spacingX;
      const levelY = 100;
      const y = (depth * levelY) + 60;
      positions.set(node.id, { x, y });
      inorder(node.right, depth+1);
    }
    inorder(rootClone, 0);

    // center horizontally in wrap
    let minX = Infinity, maxX = -Infinity;
    positions.forEach(p => { if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x; });
    if(minX === Infinity) minX = 0, maxX = 0;
    const treeWidth = Math.max(1, maxX - minX);
    const wrapWidth = wrap.clientWidth || 800;
    const offset = (wrapWidth / 2) - (minX + treeWidth / 2);
    const final = new Map();
    positions.forEach((p, id) => final.set(id, { x: p.x + offset, y: p.y }));
    return final;
  }

  // ---------------- Clone current tree state by applying swaps up to stepIndex ----------------
  function clone(node){
    if(!node) return null;
    return { id: node.id, val: node.val, left: clone(node.left), right: clone(node.right) };
  }
  function applyStepsToClone(){
    const rootClone = clone(exampleRoot);
    for(let i=0;i<=stepIndex && i < steps.length; i++){
      const s = steps[i];
      if(s.action === 'swap'){
        const n = findById(rootClone, s.id);
        if(n){
          const tmp = n.left;
          n.left = n.right;
          n.right = tmp;
        }
      }
    }
    return rootClone;
  }
  function findById(node, id){
    if(!node) return null;
    if(node.id === id) return node;
    return findById(node.left, id) || findById(node.right, id);
  }

  // ---------------- Render nodes absolutely and draw svg lines ----------------
  function renderNodesAndLines(initiallyInvisibleIds = new Set()){
    const treeState = applyStepsToClone();
    const positions = computePositions(treeState);

    // clear DOM & SVG
    canvas.innerHTML = '';
    while(svg.firstChild) svg.removeChild(svg.firstChild);

    const idToEl = new Map();

    // create DOM nodes
    function createNodeElements(node){
      if(!node) return;
      const pos = positions.get(node.id) || { x:0, y:0 };
      const el = document.createElement('div');
      el.className = 'node-item';
      el.style.left = pos.x + 'px';
      el.style.top = pos.y + 'px';
      el.dataset.id = node.id;

      const bubble = document.createElement('div');
      bubble.className = 'node-bubble';
      if(initiallyInvisibleIds.has(node.id)) bubble.classList.add('fading'); // start invisible for post-swap fade-in
      bubble.textContent = node.val;
      el.appendChild(bubble);

      const lbl = document.createElement('div');
      lbl.className = 'node-label';
      lbl.textContent = ''; // optional
      el.appendChild(lbl);

      canvas.appendChild(el);
      idToEl.set(node.id, el);

      createNodeElements(node.left);
      createNodeElements(node.right);
    }
    createNodeElements(treeState);

    // draw lines using positions (centers)
    positions.forEach((pos, id) => {
      const node = findById(treeState, id);
      if(!node) return;
      if(node.left){
        const cpos = positions.get(node.left.id);
        if(cpos) drawLine(pos.x, pos.y, cpos.x, cpos.y);
      }
      if(node.right){
        const cpos = positions.get(node.right.id);
        if(cpos) drawLine(pos.x, pos.y, cpos.x, cpos.y);
      }
    });

    // highlight current step's node (visit or swap)
    document.querySelectorAll('.node-bubble.current').forEach(el => el.classList.remove('current'));
    const cur = steps[stepIndex];
    if(cur){
      const el = idToEl.get(cur.id);
      if(el){
        const b = el.querySelector('.node-bubble');
        if(b) b.classList.add('current');
      }
    }

    return { idToEl, positions, treeState };
  }

  function drawLine(x1,y1,x2,y2){
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    // use centers directly
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    svg.appendChild(line);
  }

  // ---------------- Cross-fade swap animation (robust) ----------------
  // We will:
  //  - render PRE-swap state (apply steps up to stepIndex-1), fade out child bubbles
  //  - then increment stepIndex (so swap is applied), re-render with child bubbles initially invisible, then fade them in
  function animateSwapCrossFade(step, callback){
    // PRE-SWAP: render prev state (stepIndex - 1)
    const prevIndex = Math.max(0, stepIndex - 1);
    // temporarily render prev-state: set stepIndex to prev, render pre DOM, then restore
    const saved = stepIndex;
    stepIndex = prevIndex;
    const pre = renderNodesAndLines();
    // restore stepIndex (will be advanced by caller before calling animation)
    stepIndex = saved;

    // find children ids from PRE state
    const treeBefore = applyStepsToClone(); // with current stepIndex (we restored), we actually need the pre-swap tree; so temporarily compute it:
    // but easier: compute treeBefore by applying up to prevIndex
    function cloneUpTo(idx){
      const rootClone = clone(exampleRoot);
      for(let i=0;i<=idx && i < steps.length; i++){
        const s = steps[i];
        if(s.action==='swap'){
          const n = findById(rootClone, s.id);
          if(n){
            const tmp = n.left; n.left = n.right; n.right = tmp;
          }
        }
      }
      return rootClone;
    }
    const treePrev = cloneUpTo(prevIndex);
    const targetNodeBefore = findById(treePrev, step.id);
    const leftId = targetNodeBefore && targetNodeBefore.left ? targetNodeBefore.left.id : null;
    const rightId = targetNodeBefore && targetNodeBefore.right ? targetNodeBefore.right.id : null;

    // fade out pre-swap child bubbles if present
    const fadeEls = [];
    if(leftId){
      const leftDom = pre.idToEl.get(leftId);
      if(leftDom){
        const b = leftDom.querySelector('.node-bubble');
        if(b) { b.classList.add('fading'); fadeEls.push(b); }
      }
    }
    if(rightId){
      const rightDom = pre.idToEl.get(rightId);
      if(rightDom){
        const b = rightDom.querySelector('.node-bubble');
        if(b) { b.classList.add('fading'); fadeEls.push(b); }
      }
    }

    const fadeOutMs = 320;
    setTimeout(() => {
      // advance stepIndex so swap is logically applied
      // Note: caller already incremented stepIndex before calling animateSwapCrossFade in our flow; ensure caller increments
      // Here we assume stepIndex already points to the swap step (that's how next() is implemented below)
      // Re-render POST-swap with swapped tree, but make swapped child bubbles initially invisible and then fade-in
      const postInitiallyInvisible = new Set();
      if(leftId) postInitiallyInvisible.add(leftId);
      if(rightId) postInitiallyInvisible.add(rightId);

      const post = renderNodesAndLines(postInitiallyInvisible);

      // force children invisible, then fade-in
      postInitiallyInvisible.forEach(id => {
        const dom = post.idToEl.get(id);
        if(dom){
          const b = dom.querySelector('.node-bubble');
          if(b){
            b.style.opacity = '0';
            b.style.transition = 'opacity .32s ease';
            // small timeout to ensure style applied
            setTimeout(()=> b.style.opacity = '1', 20);
            // cleanup later
            setTimeout(()=> { b.style.transition = ''; b.style.opacity = ''; }, 400);
          }
        }
      });

      // after fade-in end, finalize (redraw lines)
      setTimeout(() => {
        drawLines(); // ensure lines match final positions
        // cleanup any transient 'fading' classes
        document.querySelectorAll('.node-bubble.fading').forEach(el => el.classList.remove('fading'));
        callback && callback();
      }, 420);
    }, fadeOutMs);
  }

  // ---------------- Main render flow ----------------
  function render(){
    if(steps.length === 0) return;
    const s = steps[stepIndex];
    if(!s) return;

    if(s.action === 'visit'){
      infoEl.textContent = `Visiting node ${s.val} (id=${s.id})`;
      renderNodesAndLines(); // static
      updateButtons();
      return;
    }

    if(s.action === 'swap'){
      // swap step animation: caller should have incremented stepIndex already (we implement next() to increment then call render)
      // animate cross-fade: we pass the step object (which has id/val)
      infoEl.textContent = `Swapping children of node ${s.val} (id=${s.id}) — animating`;
      animateSwapCrossFade(s, () => {
        updateButtons();
      });
      return;
    }
  }

  function updateButtons(){
    prevBtn.disabled = stepIndex <= 0;
    nextBtn.disabled = stepIndex >= steps.length - 1;
  }

  // ---------------- Controls (increment stepIndex appropriately) ----------------
  function doNext(){
    if(stepIndex >= steps.length - 1) return;
    stepIndex++;
    render();
  }
  function doPrev(){
    if(stepIndex <= 0) return;
    stepIndex--;
    render();
  }
  function runToEnd(){
    function stepForward(){
      if(stepIndex < steps.length - 1){
        stepIndex++;
        render();
        // wait sufficiently for possible animation
        setTimeout(stepForward, 480);
      }
    }
    stepForward();
  }
  function doReset(){
    stepIndex = 0;
    render();
  }

  nextBtn.addEventListener('click', doNext);
  prevBtn.addEventListener('click', doPrev);
  runBtn.addEventListener('click', runToEnd);
  resetBtn.addEventListener('click', doReset);

  // initial paint
  render();

  // redraw on resize
  window.addEventListener('resize', () => { clearTimeout(window.__treeResizeTimer); window.__treeResizeTimer = setTimeout(render, 120); });

})();
</script>
</body>
</html>
