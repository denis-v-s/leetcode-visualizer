<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Invert Binary Tree — Visualization (LC 226)</title>
<style>
  :root{
    --bg:#f7fafc;
    --node-bg:#2563eb;
    --node-size:48px;
    --highlight:#f59e0b;
    --text:#111827;
  }
  body{font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);padding:18px;}
  h1{margin:0 0 12px 0;font-size:20px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
  button{padding:8px 12px;border-radius:8px;border:1px solid #cbd5e1;background:#fff;cursor:pointer}
  button:disabled{opacity:.45;cursor:not-allowed}
  pre#info{background:#fff;padding:10px;border:1px solid #e6e6e6;border-radius:8px;min-height:46px;white-space:pre-wrap;margin-bottom:12px}

  /* tree area */
  .tree-wrap{position:relative;border-radius:10px;padding:12px;background:linear-gradient(180deg,#ffffff,#fbfdff);box-shadow:0 4px 12px rgba(2,6,23,0.06);min-height:420px}
  svg#lines{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;overflow:visible}
  .tree-canvas{position:relative;width:100%;height:100%}

  /* nodes absolute positioned */
  .node-item{position:absolute;transform:translate(-50%,-50%);display:flex;flex-direction:column;align-items:center;pointer-events:auto}
  .node-bubble{width:var(--node-size);height:var(--node-size);border-radius:50%;background:var(--node-bg);color:#fff;display:flex;align-items:center;justify-content:center;font-weight:700;box-shadow:0 6px 18px rgba(37,99,235,0.12);transition:opacity .3s ease, transform .18s ease}
  .node-bubble.current{outline:4px solid var(--highlight);transform:scale(1.08)}
  .node-bubble.fading{opacity:0}
  .node-label{margin-top:6px;font-size:12px;color:#374151}
  line{stroke:#6b7280;stroke-width:2;stroke-linecap:round}

  @media (max-width:720px){
    :root{--node-size:40px}
  }
</style>
</head>
<body>
  <h1>LeetCode 226 — Invert Binary Tree (classic layout + smooth cross-fade swaps)</h1>

  <div class="controls">
    <button id="prevBtn">Prev</button>
    <button id="nextBtn">Next</button>
    <button id="runBtn">Run to End</button>
    <button id="resetBtn">Reset</button>
  </div>

  <pre id="info">Step info will appear here</pre>

  <div class="tree-wrap" id="treeWrap">
    <svg id="lines" xmlns="http://www.w3.org/2000/svg"></svg>
    <div id="canvas" class="tree-canvas"></div>
  </div>

<script>
(() => {
  // ---------------- Example tree (replaceable) ----------------
  const EXAMPLE = {
    val: 4,
    left: { val:2, left:{val:1}, right:{val:3} },
    right: { val:7, left:{val:6}, right:{val:9} }
  };

  // ---------------- state ----------------
  let steps = [];     // sequence of {action: 'visit'|'swap', id, val}
  let stepIndex = 0;

  // ---------------- helpers: consistent id assignment ----------------
  let _idCounter = 1;
  function cloneWithId(node){
    if(!node) return null;
    return { id: _idCounter++, val: node.val, left: cloneWithId(node.left), right: cloneWithId(node.right) };
  }

  // build canonical tree copy (this is the single source-of-truth for ids)
  const exampleRoot = cloneWithId(EXAMPLE);

  // build steps (visit, recurse left, recurse right, swap) using the same exampleRoot structure
  function buildSteps(root){
    if(!root) return;
    steps.push({ action: 'visit', id: root.id, val: root.val });
    buildSteps(root.left);
    buildSteps(root.right);
    steps.push({ action: 'swap', id: root.id, val: root.val });
  }
  buildSteps(exampleRoot);

  // ---------------- DOM refs ----------------
  const wrap = document.getElementById('treeWrap');
  const canvas = document.getElementById('canvas');
  const svg = document.getElementById('lines');
  const infoEl = document.getElementById('info');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const runBtn = document.getElementById('runBtn');
  const resetBtn = document.getElementById('resetBtn');

  // ---------------- safety utilities ----------------
  function clone(node){
    if(!node) return null;
    return { id: node.id, val: node.val, left: clone(node.left), right: clone(node.right) };
  }

  function findById(node, id){
    if(!node) return null;
    if(node.id === id) return node;
    return findById(node.left, id) || findById(node.right, id);
  }

  // ---------------- apply swaps up to an index -> returns a clone representing current state ----------------
  function applyStepsToClone(uptoIndex){
    const rootClone = clone(exampleRoot);
    for(let i=0;i<=uptoIndex && i < steps.length; i++){
      const s = steps[i];
      if(s.action === 'swap'){
        const n = findById(rootClone, s.id);
        if(n){
          const tmp = n.left;
          n.left = n.right;
          n.right = tmp;
        }
      }
    }
    return rootClone;
  }

  // ---------------- layout: compute positions using inorder numbering (single pass), then center horizontally ----------------
  function computePositions(rootClone){
    const positions = new Map();
    let order = 0;
    const visited = new Set();

    function inorder(n, depth){
      if(!n || visited.has(n.id)) return;
      visited.add(n.id);
      inorder(n.left, depth+1);
      order++;
      const spacingX = 120; // adjust horizontal spacing as needed
      const x = order * spacingX;
      const levelY = 100;
      const y = (depth * levelY) + 60;
      positions.set(n.id, { x, y });
      inorder(n.right, depth+1);
    }
    inorder(rootClone, 0);

    // center
    if(positions.size === 0) return positions;
    let minX = Infinity, maxX = -Infinity;
    positions.forEach(p => { if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x; });
    const treeWidth = Math.max(1, maxX - minX);
    const wrapWidth = wrap.clientWidth || 800;
    const offset = (wrapWidth / 2) - (minX + treeWidth/2);

    const final = new Map();
    positions.forEach((p,id) => final.set(id, { x: p.x + offset, y: p.y }));
    return final;
  }

  // ---------------- render nodes absolute + draw svg lines (positions from computePositions) ----------------
  function renderNodesAndLines(initialInvisible = new Set()){
    const treeState = applyStepsToClone(stepIndex); // render state up to current stepIndex
    const positions = computePositions(treeState);

    // clear canvas and svg
    canvas.innerHTML = '';
    while(svg.firstChild) svg.removeChild(svg.firstChild);

    const idToEl = new Map();

    // create node elements
    function create(node){
      if(!node) return;
      const pos = positions.get(node.id) || { x:0, y:0 };
      const el = document.createElement('div');
      el.className = 'node-item';
      el.style.left = pos.x + 'px';
      el.style.top = pos.y + 'px';
      el.dataset.id = node.id;

      const bubble = document.createElement('div');
      bubble.className = 'node-bubble';
      if(initialInvisible.has(node.id)) bubble.classList.add('fading'); // start invisible when requested
      bubble.textContent = node.val;
      el.appendChild(bubble);

      const lbl = document.createElement('div');
      lbl.className = 'node-label';
      lbl.textContent = ''; // optional
      el.appendChild(lbl);

      canvas.appendChild(el);
      idToEl.set(node.id, el);

      create(node.left);
      create(node.right);
    }
    create(treeState);

    // draw lines
    positions.forEach((pos, id) => {
      const node = findById(treeState, id);
      if(!node) return;
      if(node.left){
        const childPos = positions.get(node.left.id);
        if(childPos) drawLine(pos.x, pos.y, childPos.x, childPos.y);
      }
      if(node.right){
        const childPos = positions.get(node.right.id);
        if(childPos) drawLine(pos.x, pos.y, childPos.x, childPos.y);
      }
    });

    // highlight current node (visit or swap)
    document.querySelectorAll('.node-bubble.current').forEach(el => el.classList.remove('current'));
    const curStep = steps[stepIndex];
    if(curStep){
      const el = idToEl.get(curStep.id);
      if(el){
        const bubble = el.querySelector('.node-bubble');
        if(bubble) bubble.classList.add('current');
      }
    }

    return { idToEl, positions, treeState };
  }

  function drawLine(x1,y1,x2,y2){
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('stroke', '#6b7280');
    line.setAttribute('stroke-width', '2');
    line.setAttribute('stroke-linecap', 'round');
    svg.appendChild(line);
  }

  // ---------------- cross-fade swap animation: PRE -> fade out children -> POST (swap applied) -> fade in ----------------
  function animateCrossFadeSwap(step, done){
    // PRE state index is stepIndex - 1
    const prevIndex = Math.max(0, stepIndex - 1);

    // Render PRE state (apply up to prevIndex)
    const prevStateClone = applyStepsToClone(prevIndex);
    const prevPositions = computePositions(prevStateClone);

    // render pre DOM (temporarily) by using a helper that uses a specific 'upTo' index
    function renderUpTo(upTo, initialInvisibleSet = new Set()){
      // temporarily set global stepIndex to upTo to let renderNodesAndLines use that state
      const saved = stepIndex;
      stepIndex = upTo;
      const res = renderNodesAndLines(initialInvisibleSet);
      stepIndex = saved;
      return res;
    }

    // pre DOM (no swap yet)
    const pre = renderUpTo(prevIndex);

    // identify children ids in pre-state for the target node
    const treePrev = prevStateClone;
    const targetPrev = findById(treePrev, step.id);
    const leftId = targetPrev && targetPrev.left ? targetPrev.left.id : null;
    const rightId = targetPrev && targetPrev.right ? targetPrev.right.id : null;

    // fade out those child bubbles (if present)
    if(leftId){
      const leftDom = pre.idToEl.get(leftId);
      if(leftDom){
        const b = leftDom.querySelector('.node-bubble');
        if(b) b.classList.add('fading');
      }
    }
    if(rightId){
      const rightDom = pre.idToEl.get(rightId);
      if(rightDom){
        const b = rightDom.querySelector('.node-bubble');
        if(b) b.classList.add('fading');
      }
    }

    // wait fade-out
    const fadeOutMs = 320;
    setTimeout(() => {
      // Now render POST (swap is applied up to current stepIndex)
      // We'll render POST with the swapped child ids initially invisible (so we can fade them in)
      const initialInvisible = new Set();
      if(leftId) initialInvisible.add(leftId);
      if(rightId) initialInvisible.add(rightId);

      const post = renderUpTo(stepIndex, initialInvisible);

      // small delay then fade-in targeted child bubbles
      setTimeout(() => {
        if(leftId){
          const ld = post.idToEl.get(leftId);
          if(ld){
            const b = ld.querySelector('.node-bubble');
            if(b){
              b.style.opacity = '0';
              b.style.transition = 'opacity .32s ease';
              // trigger paint then fade in
              requestAnimationFrame(()=> requestAnimationFrame(()=> b.style.opacity = '1'));
              // cleanup later
              setTimeout(()=> { b.style.transition = ''; b.style.opacity = ''; }, 420);
            }
          }
        }
        if(rightId){
          const rd = post.idToEl.get(rightId);
          if(rd){
            const b = rd.querySelector('.node-bubble');
            if(b){
              b.style.opacity = '0';
              b.style.transition = 'opacity .32s ease';
              requestAnimationFrame(()=> requestAnimationFrame(()=> b.style.opacity = '1'));
              setTimeout(()=> { b.style.transition = ''; b.style.opacity = ''; }, 420);
            }
          }
        }

        // finalize after fade-in
        setTimeout(() => {
          // cleanup any fading classes left behind
          document.querySelectorAll('.node-bubble.fading').forEach(el => el.classList.remove('fading'));
          drawLines();
          done && done();
        }, 460);
      }, 30);
    }, fadeOutMs);
  }

  // ---------------- main render logic ----------------
  function render(){
    if(steps.length === 0) return;
    const s = steps[stepIndex];
    if(!s) return;

    if(s.action === 'visit'){
      infoEl.textContent = `Visiting node ${s.val} (id=${s.id})`;
      // render state up to current stepIndex (visit step does not change children)
      renderNodesAndLines(new Set());
      updateButtons();
      return;
    }

    if(s.action === 'swap'){
      infoEl.textContent = `Swapping children of node ${s.val} (id=${s.id}) — animating...`;
      // animate cross-fade. Note: stepIndex should already point to this swap step (caller increments before calling render)
      animateCrossFadeSwap(s, () => {
        updateButtons();
      });
      return;
    }
  }

  // ---------------- controls ----------------
  function updateButtons(){
    prevBtn.disabled = stepIndex <= 0;
    nextBtn.disabled = stepIndex >= steps.length - 1;
  }

  function doNext(){
    if(stepIndex >= steps.length - 1) return;
    stepIndex++;
    render();
  }
  function doPrev(){
    if(stepIndex <= 0) return;
    stepIndex--;
    render();
  }
  function runToEnd(){
    function stepForward(){
      if(stepIndex < steps.length - 1){
        stepIndex++;
        render();
        setTimeout(stepForward, 520); // leave time for possible animations
      }
    }
    stepForward();
  }
  function doReset(){
    stepIndex = 0;
    render();
  }

  nextBtn.addEventListener('click', doNext);
  prevBtn.addEventListener('click', doPrev);
  runBtn.addEventListener('click', runToEnd);
  resetBtn.addEventListener('click', doReset);

  // initial paint
  render();

  // redraw lines on resize
  window.addEventListener('resize', () => { clearTimeout(window.__resizeTimer); window.__resizeTimer = setTimeout(render, 140); });

})();
</script>
</body>
</html>
