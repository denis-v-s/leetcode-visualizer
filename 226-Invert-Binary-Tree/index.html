<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Invert Binary Tree — Visualization (LC 226)</title>
<style>
  :root{
    --bg:#f7fafc;
    --node-bg:#2563eb;
    --node-size:48px;
    --highlight:#f59e0b;
    --text:#111827;
  }
  body{font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);padding:18px;margin:0;}
  .page { max-width:1100px;margin:12px auto; }
  h1{margin:0 0 12px 0;font-size:20px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
  button{padding:8px 12px;border-radius:8px;border:1px solid #cbd5e1;background:#fff;cursor:pointer}
  button:disabled{opacity:.45;cursor:not-allowed}
  pre#info{background:#fff;padding:10px;border:1px solid #e6e6e6;border-radius:8px;min-height:48px;white-space:pre-wrap;margin-bottom:12px}

  .tree-wrap{position:relative;border-radius:10px;padding:12px;background:linear-gradient(180deg,#ffffff,#fbfdff);box-shadow:0 6px 18px rgba(2,6,23,0.06);min-height:420px; overflow:visible}
  svg#lines{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;overflow:visible}
  .tree-canvas{position:relative;width:100%;height:100%}

  .node-item{position:absolute;transform:translate(-50%,-50%);display:flex;flex-direction:column;align-items:center;pointer-events:auto}
  .node-bubble{width:var(--node-size);height:var(--node-size);border-radius:50%;background:var(--node-bg);color:#fff;display:flex;align-items:center;justify-content:center;font-weight:700;box-shadow:0 8px 24px rgba(37,99,235,0.12);transition:opacity .32s ease, transform .22s ease}
  .node-bubble.current{outline:4px solid var(--highlight);transform:scale(1.08)}
  .node-bubble.fading{opacity:0}
  .node-label{margin-top:8px;font-size:12px;color:#374151}
  line{stroke:#6b7280;stroke-width:2;stroke-linecap:round}

  @media (max-width:700px){:root{--node-size:40px}}
</style>
</head>
<body>
  <div class="page">
    <h1>LeetCode 226 — Invert Binary Tree (centered layout + cross-fade swap)</h1>

    <div class="controls">
      <button id="prevBtn">Prev</button>
      <button id="nextBtn">Next</button>
      <button id="runBtn">Run to End</button>
      <button id="resetBtn">Reset</button>
    </div>

    <pre id="info">Step info will appear here</pre>

    <div class="tree-wrap" id="treeWrap">
      <svg id="lines" xmlns="http://www.w3.org/2000/svg"></svg>
      <div id="canvas" class="tree-canvas"></div>
    </div>
  </div>

<script>
(() => {
  // ---------------- Example tree ----------------
  const EXAMPLE = {
    val: 4,
    left: { val:2, left:{val:1}, right:{val:3} },
    right: { val:7, left:{val:6}, right:{val:9} }
  };

  // ---------------- State ----------------
  let steps = [];     // { action: 'visit'|'swap', id, val }
  let stepIndex = 0;

  // ---------------- Helpers: clone with stable unique IDs ----------------
  let _idCounter = 1;
  function cloneWithId(node){
    if(!node) return null;
    return { id: (_idCounter++), val: node.val, left: cloneWithId(node.left), right: cloneWithId(node.right) };
  }

  // Build a single canonical tree (used for steps and base structure)
  const canonicalRoot = cloneWithId(EXAMPLE);

  // Build steps (visit, recurse left, recurse right, swap) on canonical tree
  function buildSteps(root){
    if(!root) return;
    steps.push({ action:'visit', id: root.id, val: root.val });
    buildSteps(root.left);
    buildSteps(root.right);
    steps.push({ action:'swap', id: root.id, val: root.val });
  }
  buildSteps(canonicalRoot);

  // ---------------- DOM refs ----------------
  const wrap = document.getElementById('treeWrap');
  const canvas = document.getElementById('canvas');
  const svg = document.getElementById('lines');
  const infoEl = document.getElementById('info');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const runBtn = document.getElementById('runBtn');
  const resetBtn = document.getElementById('resetBtn');

  // ---------------- Utility functions ----------------
  function clone(node){
    if(!node) return null;
    return { id: node.id, val: node.val, left: clone(node.left), right: clone(node.right) };
  }
  function findById(node, id){
    if(!node) return null;
    if(node.id === id) return node;
    return findById(node.left, id) || findById(node.right, id);
  }

  // Apply swaps up to index (inclusive)
  function treeStateAt(index){
    const rootClone = clone(canonicalRoot);
    for(let i=0;i<=index && i < steps.length; i++){
      const s = steps[i];
      if(s.action === 'swap'){
        const n = findById(rootClone, s.id);
        if(n){
          const tmp = n.left;
          n.left = n.right;
          n.right = tmp;
        }
      }
    }
    return rootClone;
  }

  // ---------------- Layout: compute inorder positions (guarded) ----------------
  function computePositions(root){
    const positions = new Map();
    let order = 0;
    const visited = new Set();
    function inorder(node, depth){
      if(!node || visited.has(node.id)) return;
      visited.add(node.id);
      inorder(node.left, depth+1);
      order++;
      const spacingX = 120;
      const x = order * spacingX;
      const levelY = 120;
      const y = (depth * levelY) + 60;
      positions.set(node.id, { x, y });
      inorder(node.right, depth+1);
    }
    inorder(root, 0);

    // center horizontally
    let minX = Infinity, maxX = -Infinity;
    positions.forEach(p => { if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x; });
    if(minX === Infinity){ minX = 0; maxX = 0; }
    const treeWidth = Math.max(1, maxX - minX);
    const wrapWidth = wrap.clientWidth || 900;
    const offset = (wrapWidth / 2) - (minX + treeWidth / 2);
    const final = new Map();
    positions.forEach((p, id) => final.set(id, { x: p.x + offset, y: p.y }));
    return final;
  }

  // ---------------- Drawing helpers ----------------
  function clearCanvas(){
    canvas.innerHTML = '';
    while(svg.firstChild) svg.removeChild(svg.firstChild);
  }
  function drawLine(x1,y1,x2,y2){
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('stroke', '#6b7280');
    line.setAttribute('stroke-width', '2');
    line.setAttribute('stroke-linecap', 'round');
    svg.appendChild(line);
  }

  // ---------------- Render state: create DOM nodes and lines ----------------
  // initiallyInvisible: Set of ids that should start invisible (used for post-swap fade-in)
  function renderState(rootState, initiallyInvisible = new Set()){
    const positions = computePositions(rootState);
    clearCanvas();
    const idToEl = new Map();

    (function createEls(node){
      if(!node) return;
      const p = positions.get(node.id) || {x:0,y:0};
      const el = document.createElement('div');
      el.className = 'node-item';
      el.style.left = p.x + 'px';
      el.style.top = p.y + 'px';
      el.dataset.id = node.id;

      const bubble = document.createElement('div');
      bubble.className = 'node-bubble';
      if(initiallyInvisible.has(node.id)) bubble.classList.add('fading');
      bubble.textContent = node.val;
      el.appendChild(bubble);

      const lbl = document.createElement('div');
      lbl.className = 'node-label';
      lbl.textContent = ''; // optional
      el.appendChild(lbl);

      canvas.appendChild(el);
      idToEl.set(node.id, el);

      createEls(node.left);
      createEls(node.right);
    })(rootState);

    // draw lines after nodes created
    positions.forEach((pos, id) => {
      const node = findById(rootState, id);
      if(!node) return;
      if(node.left){
        const cpos = positions.get(node.left.id);
        if(cpos) drawLine(pos.x, pos.y, cpos.x, cpos.y);
      }
      if(node.right){
        const cpos = positions.get(node.right.id);
        if(cpos) drawLine(pos.x, pos.y, cpos.x, cpos.y);
      }
    });

    return { idToEl, positions, state: rootState };
  }

  // ---------------- Highlight and info ----------------
  function applyHighlight(){
    document.querySelectorAll('.node-bubble.current').forEach(el => el.classList.remove('current'));
    const cur = steps[stepIndex];
    if(cur){
      const el = document.querySelector(`.node-item[data-id="${cur.id}"]`);
      if(el){
        const b = el.querySelector('.node-bubble');
        if(b) b.classList.add('current');
      }
      infoEl.textContent = cur.action === 'visit'
        ? `Visiting node ${cur.val} (id=${cur.id})`
        : `Swap step: children of node ${cur.val} (id=${cur.id}) will be swapped`;
    } else {
      infoEl.textContent = 'Done';
    }
  }

  // ---------------- updateButtons ----------------
  function updateButtons(){
    prevBtn.disabled = stepIndex <= 0;
    nextBtn.disabled = stepIndex >= steps.length - 1;
  }

  // ---------------- Cross-fade swap animation ----------------
  // caller should increment stepIndex BEFORE calling render for swap step.
  function animateSwapCrossFade(step, prevIndex, done){
    // PRE-swap: render tree at prevIndex
    const preState = treeStateAt(prevIndex);
    const pre = renderState(preState);

    // determine child ids in PRE state
    const targetPre = findById(preState, step.id);
    const leftId = targetPre && targetPre.left ? targetPre.left.id : null;
    const rightId = targetPre && targetPre.right ? targetPre.right.id : null;

    // fade out pre children if present
    if(leftId && pre.idToEl.get(leftId)){
      const b = pre.idToEl.get(leftId).querySelector('.node-bubble'); if(b) b.classList.add('fading');
    }
    if(rightId && pre.idToEl.get(rightId)){
      const b = pre.idToEl.get(rightId).querySelector('.node-bubble'); if(b) b.classList.add('fading');
    }

    const fadeOutMs = 320;
    setTimeout(() => {
      // POST-swap: render tree at current stepIndex (swap already applied in treeStateAt because caller advanced stepIndex)
      const postState = treeStateAt(stepIndex);
      // make swapped child ids initially invisible so we can fade them in
      const initiallyInvisible = new Set();
      if(leftId) initiallyInvisible.add(leftId);
      if(rightId) initiallyInvisible.add(rightId);

      const post = renderState(postState, initiallyInvisible);

      // fade-in those child bubbles
      initiallyInvisible.forEach(id => {
        const dom = post.idToEl.get(id);
        if(dom){
          const b = dom.querySelector('.node-bubble');
          if(b){
            b.style.opacity = '0';
            b.style.transition = 'opacity .34s ease';
            setTimeout(()=> b.style.opacity = '1', 12);
            // cleanup after animation
            setTimeout(()=> { b.style.transition = ''; b.style.opacity = ''; }, 420);
          }
        }
      });

      // finalize after fade-in
      setTimeout(() => {
        applyHighlight();
        updateButtons();
        done && done();
      }, 460);
    }, fadeOutMs);
  }

  // ---------------- Main render driver ----------------
  function render(){
    if(steps.length === 0) return;
    const s = steps[stepIndex];
    if(!s) return;

    if(s.action === 'visit'){
      const state = treeStateAt(stepIndex);
      renderState(state);
      applyHighlight();
      updateButtons();
      return;
    }

    if(s.action === 'swap'){
      // animate: caller must have incremented stepIndex before calling render for swap
      const prevIndex = Math.max(0, stepIndex - 1);
      animateSwapCrossFade(s, prevIndex, () => {
        updateButtons();
      });
      updateButtons();
      return;
    }
  }

  // ---------------- Controls ----------------
  function doNext(){
    if(stepIndex >= steps.length - 1) return;
    stepIndex++;
    render();
  }
  function doPrev(){
    if(stepIndex <= 0) return;
    stepIndex--;
    render();
  }
  function runToEnd(){
    function stepForward(){
      if(stepIndex < steps.length - 1){
        stepIndex++;
        render();
        setTimeout(stepForward, 520);
      }
    }
    stepForward();
  }
  function doReset(){
    stepIndex = 0;
    render();
  }

  nextBtn.addEventListener('click', doNext);
  prevBtn.addEventListener('click', doPrev);
  runBtn.addEventListener('click', runToEnd);
  resetBtn.addEventListener('click', doReset);

  // initial render
  render();

  // redraw on resize
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => { render(); }, 120);
  });
})();
</script>
</body>
</html>
