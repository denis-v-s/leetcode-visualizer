<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Invert Binary Tree — Visualization (LC 226)</title>
<style>
  :root{
    --bg:#f7fafc;
    --node-bg:#2563eb;
    --node-size:48px;
    --highlight:#f59e0b;
    --text:#111827;
  }
  body{font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);padding:18px;margin:0;}
  .page { max-width:1100px;margin:12px auto; }
  h1{margin:0 0 12px 0;font-size:20px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
  button{padding:8px 12px;border-radius:8px;border:1px solid #cbd5e1;background:#fff;cursor:pointer}
  button:disabled{opacity:.45;cursor:not-allowed}
  pre#info{background:#fff;padding:10px;border:1px solid #e6e6e6;border-radius:8px;min-height:48px;white-space:pre-wrap;margin-bottom:12px}

  .tree-wrap{position:relative;border-radius:10px;padding:12px;background:linear-gradient(180deg,#ffffff,#fbfdff);box-shadow:0 6px 18px rgba(2,6,23,0.06);min-height:420px; overflow:visible}
  svg#lines{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;overflow:visible}
  .tree-canvas{position:relative;width:100%;height:100%}

  .node-item{position:absolute;transform:translate(-50%,-50%);display:flex;flex-direction:column;align-items:center;pointer-events:auto}
  .node-bubble{width:var(--node-size);height:var(--node-size);border-radius:50%;background:var(--node-bg);color:#fff;display:flex;align-items:center;justify-content:center;font-weight:700;box-shadow:0 8px 24px rgba(37,99,235,0.12);transition:opacity .32s ease, transform .22s ease}
  .node-bubble.current{outline:4px solid var(--highlight);transform:scale(1.08)}
  .node-bubble.fading{opacity:0}
  .node-label{margin-top:8px;font-size:12px;color:#374151}
  line{stroke:#6b7280;stroke-width:2;stroke-linecap:round}

  @media (max-width:700px){:root{--node-size:40px}}
</style>
</head>
<body>
  <div class="page">
    <h1>LeetCode 226 — Invert Binary Tree (classic centered layout + cross-fade swap)</h1>

    <div class="controls">
      <button id="prevBtn">Prev</button>
      <button id="nextBtn">Next</button>
      <button id="runBtn">Run to End</button>
      <button id="resetBtn">Reset</button>
    </div>

    <pre id="info">Step info will appear here</pre>

    <div class="tree-wrap" id="treeWrap">
      <svg id="lines" xmlns="http://www.w3.org/2000/svg"></svg>
      <div id="canvas" class="tree-canvas"></div>
    </div>
  </div>

<script>
(() => {
  // ---------------- Example tree (you can replace this with different shapes) ----------------
  const EXAMPLE = {
    val: 4,
    left: { val:2, left:{val:1}, right:{val:3} },
    right: { val:7, left:{val:6}, right:{val:9} }
  };

  // ---------------- State ----------------
  let steps = [];     // { action: 'visit'|'swap', id, val }
  let stepIndex = 0;

  // ---------------- Helpers: clone with stable unique IDs ----------------
  let _idCounter = 1;
  function cloneWithId(node){
    if(!node) return null;
    return { id: (_idCounter++), val: node.val, left: cloneWithId(node.left), right: cloneWithId(node.right) };
  }

  // Build a single canonical tree (used for steps and base structure)
  const canonicalRoot = cloneWithId(EXAMPLE);

  // Build steps (visit, recurse left, recurse right, swap) on canonical tree
  function buildSteps(root){
    if(!root) return;
    steps.push({ action:'visit', id: root.id, val: root.val });
    buildSteps(root.left);
    buildSteps(root.right);
    steps.push({ action:'swap', id: root.id, val: root.val });
  }
  buildSteps(canonicalRoot);

  // ---------------- DOM refs ----------------
  const wrap = document.getElementById('treeWrap');
  const canvas = document.getElementById('canvas');
  const svg = document.getElementById('lines');
  const infoEl = document.getElementById('info');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const runBtn = document.getElementById('runBtn');
  const resetBtn = document.getElementById('resetBtn');

  // ---------------- Utility: clone tree structure (no ids reassigned) ----------------
  function clone(node){
    if(!node) return null;
    return { id: node.id, val: node.val, left: clone(node.left), right: clone(node.right) };
  }

  // Find node by id in a given tree
  function findById(node, id){
    if(!node) return null;
    if(node.id === id) return node;
    return findById(node.left, id) || findById(node.right, id);
  }

  // ---------------- Apply steps to get tree state at index (inclusive) ----------------
  function treeStateAt(index){
    const rootClone = clone(canonicalRoot);
    for(let i=0;i<=index && i < steps.length; i++){
      const s = steps[i];
      if(s.action === 'swap'){
        const n = findById(rootClone, s.id);
        if(n){
          const tmp = n.left;
          n.left = n.right;
          n.right = tmp;
        }
      }
    }
    return rootClone;
  }

  // ---------------- Layout: compute positions using inorder numbering ----------------
  function computePositions(root){
    const positions = new Map();
    let order = 0;
    const visited = new Set();

    function inorder(node, depth){
      if(!node || visited.has(node.id)) return;
      visited.add(node.id);
      inorder(node.left, depth+1);
      order++;
      const spacingX = 120; // adjust horizontal spacing
      const x = order * spacingX;
      const levelY = 120; // vertical spacing
      const y = (depth * levelY) + 60;
      positions.set(node.id, { x, y });
      inorder(node.right, depth+1);
    }
    inorder(root, 0);

    // center the whole tree within wrap
    let minX = Infinity, maxX = -Infinity;
    positions.forEach(p => { if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x; });
    if(minX === Infinity){ minX = 0; maxX = 0; }
    const treeWidth = Math.max(1, maxX - minX);
    const wrapWidth = wrap.clientWidth || 900;
    const offset = (wrapWidth / 2) - (minX + treeWidth / 2);
    const final = new Map();
    positions.forEach((p, id) => final.set(id, { x: p.x + offset, y: p.y }));
    return final;
  }

  // ---------------- Drawing helpers ----------------
  function clearCanvas(){
    canvas.innerHTML = '';
    while(svg.firstChild) svg.removeChild(svg.firstChild);
  }

  function drawLine(x1, y1, x2, y2){
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('stroke', '#6b7280');
    line.setAttribute('stroke-width', '2');
    line.setAttribute('stroke-linecap', 'round');
    svg.appendChild(line);
  }

  // ---------------- Render given tree state (optionally mark some ids invisible initially) ----------------
  // returns { idToEl, positions, state }
  function renderState(rootState, initiallyInvisible = new Set()){
    const positions = computePositions(rootState);
    clearCanvas();
    const idToEl = new Map();

    (function createEls(node){
      if(!node) return;
      const p = positions.get(node.id) || {x:0,y:0};
      const el = document.createElement('div');
      el.className = 'node-item';
      el.style.left = p.x + 'px';
      el.style.top = p.y + 'px';
      el.dataset.id = node.id;

      const bubble = document.createElement('div');
      bubble.className = 'node-bubble';
      if(initiallyInvisible.has(node.id)) bubble.classList.add('fading');
      bubble.textContent = node.val;
      el.appendChild(bubble);

      const lbl = document.createElement('div');
      lbl.className = 'node-label';
      lbl.textContent = ''; // optional
      el.appendChild(lbl);

      canvas.appendChild(el);
      idToEl.set(node.id, el);

      createEls(node.left);
      createEls(node.right);
    })(rootState);

    // draw lines using positions
    positions.forEach((pos, id) => {
      const node = findById(rootState, id);
      if(!node) return;
      if(node.left){
        const cpos = positions.get(node.left.id);
        if(cpos) drawLine(pos.x, pos.y, cpos.x, cpos.y);
      }
      if(node.right){
        const cpos = positions.get(node.right.id);
        if(cpos) drawLine(pos.x, pos.y, cpos.x, cpos.y);
      }
    });

    return { idToEl, positions, state: rootState };
  }

  // ---------------- Cross-fade swap animation ----------------
  // Flow:
  // 1) Render PRE-swap state (apply up to prevIndex). Fade out the two child bubbles (if present).
  // 2) After fade-out, advance stepIndex (caller increments before calling animation) so swap is applied.
  // 3) Render POST-swap state but start swapped child bubbles invisible; then fade them in.
  // 4) Redraw lines and finalize.
  function animateSwapCrossFade(step, prevIndex, callback){
    // PRE: render tree at prevIndex
    const preState = treeStateAt(prevIndex);
    const pre = renderState(preState);

    // find children ids in preState
    const targetPre = findById(preState, step.id);
    const leftId = targetPre && targetPre.left ? targetPre.left.id : null;
    const rightId = targetPre && targetPre.right ? targetPre.right.id : null;

    // fade out existing child bubbles
    const fadeTargets = [];
    if(leftId && pre.idToEl.get(leftId)){
      const b = pre.idToEl.get(leftId).querySelector('.node-bubble');
      if(b){ b.classList.add('fading'); fadeTargets.push(b); }
    }
    if(rightId && pre.idToEl.get(rightId)){
      const b = pre.idToEl.get(rightId).querySelector('.node-bubble');
      if(b){ b.classList.add('fading'); fadeTargets.push(b); }
    }

    const fadeOutMs = 320;
    setTimeout(() => {
      // POST: render tree at current stepIndex (which caller should have set to swap step)
      const postState = treeStateAt(stepIndex);
      // For post render, make the swapped child ids initially invisible so we can fade them in
      const initiallyInvisible = new Set();
      if(leftId) initiallyInvisible.add(leftId);
      if(rightId) initiallyInvisible.add(rightId);
      const post = renderState(postState, initiallyInvisible);

      // fade-in the swapped children
      Array.from(initiallyInvisible).forEach(id => {
        const dom = post.idToEl.get(id);
        if(dom){
          const bubble = dom.querySelector('.node-bubble');
          if(bubble){
            // ensure start invisible
            bubble.style.opacity = '0';
            bubble.style.transition = 'opacity .34s ease';
            // tiny delay then fade in
            setTimeout(()=> bubble.style.opacity = '1', 10);
            // cleanup after animation
            setTimeout(()=> { bubble.style.transition = ''; bubble.style.opacity = ''; }, 420);
          }
        }
      });

      // finalize after fade-in
      setTimeout(() => {
        // ensure current highlight is applied
        applyHighlight();
        drawLines(); // ensure lines align to final positions
        callback && callback();
      }, 460);
    }, fadeOutMs);
  }

  // ---------------- Helpers for drawLines and highlight ----------------
  function drawLines(){
    // lines are already drawn by renderState; but on resize we need to re-render current state
    // re-render at current stepIndex to recompute coordinates and redraw SVG
    const state = treeStateAt(stepIndex);
    renderState(state); // this redraws SVG as well
    applyHighlight();
  }

  function applyHighlight(){
    // remove existing highlights
    document.querySelectorAll('.node-bubble.current').forEach(el => el.classList.remove('current'));
    const cur = steps[stepIndex];
    if(cur){
      // find the rendered element with this id
      const el = document.querySelector(`.node-item[data-id="${cur.id}"]`);
      if(el){
        const b = el.querySelector('.node-bubble');
        if(b) b.classList.add('current');
      }
    }
    // update info box
    const s = steps[stepIndex];
    if(s){
      infoEl.textContent = s.action === 'visit'
        ? `Visiting node ${s.val} (id=${s.id})`
        : `Swap step: children of node ${s.val} (id=${s.id}) will be swapped`;
    } else {
      infoEl.textContent = 'Done';
    }
  }

  // ---------------- Main render driver ----------------
  function render(){
    if(steps.length === 0) return;
    const s = steps[stepIndex];
    if(!s) return;

    if(s.action === 'visit'){
      // static render of tree at current stepIndex (no animation)
      const state = treeStateAt(stepIndex);
      renderState(state);
      applyHighlight();
      updateButtons();
      return;
    }

    if(s.action === 'swap'){
      // We will animate swap cross-fade.
      // Caller should have already incremented stepIndex before calling render for swap step.
      // For the animation we need prevIndex = stepIndex - 1 (state before swap).
      const prevIndex = Math.max(0, stepIndex - 1);
      animateSwapCrossFade(s, prevIndex, () => {
        updateButtons();
      });
      updateButtons();
      return;
    }
  }

  // ---------------- Controls ----------------
  function next(){
    if(stepIndex >= steps.length - 1) return;
    stepIndex++;
    render();
  }
  function prev(){
    if(stepIndex <= 0) return;
    stepIndex--;
    render();
  }
  function runToEnd(){
    const stepForward = () => {
      if(stepIndex < steps.length - 1){
        stepIndex++;
        render();
        // wait longer than animation to step again
        setTimeout(stepForward, 520);
      }
    };
    stepForward();
  }
  function resetAll(){
    stepIndex = 0;
    render();
  }

  nextBtn.addEventListener('click', next);
  prevBtn.addEventListener('click', prev);
  runBtn.addEventListener('click', runToEnd);
  resetBtn.addEventListener('click', resetAll);

  // initial render
  render();

  // keep alignment on resize
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => { render(); }, 120);
  });

})();
</script>
</body>
</html>
