<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Invert Binary Tree Visualization</title>
<style>
body { font-family: Arial; padding:20px; background:#f7fafc; }
.controls { display:flex; gap:8px; margin-bottom:12px; }
button { padding:8px 12px; border-radius:6px; background:white; border:1px solid #ccc; cursor:pointer; }
button:disabled { opacity:0.5; cursor:not-allowed; }

.tree-wrapper {
    position:relative;
    display:flex;
    justify-content:center;
    margin-top:20px;
}

.tree {
    position:relative;
    display:flex;
    flex-direction:column;
    align-items:center;
}

.node {
    display:flex;
    flex-direction:column;
    align-items:center;
    margin:20px;
    position:relative;
}

.value {
    width:40px;
    height:40px;
    border-radius:50%;
    background:#3b82f6;
    color:white;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:bold;
    transition:0.3s;
}

.current {
    outline:4px solid #f59e0b;
    transform:scale(1.2);
}

.children {
    display:flex;
    gap:60px;
    margin-top:40px;
}
line {
    stroke:#6b7280;
    stroke-width:2;
}
</style>
</head>

<body>
<h2>LeetCode 226 â€“ Invert Binary Tree (Visualization)</h2>

<div class="controls">
  <button id="prevBtn">Prev</button>
  <button id="nextBtn">Next</button>
  <button id="runBtn">Run to End</button>
  <button id="resetBtn">Reset</button>
</div>

<pre id="info"></pre>

<div class="tree-wrapper">
    <!-- SVG will be dynamically resized to match the tree -->
    <svg id="svgLines" style="position:absolute; top:0; left:0; pointer-events:none;"></svg>
    <div id="treeContainer" class="tree"></div>
</div>

<script>
(function(){
const container = document.getElementById("treeContainer");
const svgLines = document.getElementById("svgLines");
const infoEl = document.getElementById("info");

const baseTree = {
    val:4,
    left:{ val:2, left:{val:1}, right:{val:3} },
    right:{ val:7, left:{val:6}, right:{val:9} }
};

let steps = [];
let stepIndex = 0;

function clone(node){
    if(!node) return null;
    return { val:node.val, left:clone(node.left), right:clone(node.right) };
}

function recordSteps(node){
    if(!node) return;
    steps.push({action:"visit", nodeVal:node.val});
    recordSteps(node.left);
    recordSteps(node.right);
    steps.push({action:"swap", nodeVal:node.val});
}

recordSteps(clone(baseTree));

function applySteps(root){
    function find(n,val){
        if(!n) return null;
        if(n.val===val) return n;
        return find(n.left,val)||find(n.right,val);
    }
    for(let i=0;i<=stepIndex;i++){
        const s = steps[i];
        if(s.action==="swap"){
            const target = find(root, s.nodeVal);
            if(target){
                let t = target.left;
                target.left = target.right;
                target.right = t;
            }
        }
    }
}

function renderNode(node, highlight){
    if(!node) {
        const gap = document.createElement("div");
        gap.style.width = "40px";
        return gap;
    }

    const el = document.createElement("div");
    el.className = "node";

    const circle = document.createElement("div");
    circle.className = "value";
    circle.textContent = node.val;
    if(node.val === highlight) circle.classList.add("current");

    el.appendChild(circle);

    if(node.left || node.right){
        const kids = document.createElement("div");
        kids.className = "children";
        kids.appendChild(renderNode(node.left, highlight));
        kids.appendChild(renderNode(node.right, highlight));
        el.appendChild(kids);
    }
    return el;
}

function drawLines(){
    svgLines.innerHTML="";

    const treeRect = container.getBoundingClientRect();
    svgLines.setAttribute("width", treeRect.width);
    svgLines.setAttribute("height", treeRect.height);

    function connect(parentEl){
        const kids = parentEl.querySelector(".children");
        if(!kids) return;
        const pRect = parentEl.querySelector(".value").getBoundingClientRect();

        [...kids.children].forEach(child=>{
            const v = child.querySelector(".value");
            if(!v) return;
            const cRect = v.getBoundingClientRect();

            const line = document.createElementNS("http://www.w3.org/2000/svg","line");
            line.setAttribute("x1", pRect.left + pRect.width/2 - treeRect.left);
            line.setAttribute("y1", pRect.top + pRect.height/2 - treeRect.top);
            line.setAttribute("x2", cRect.left + cRect.width/2 - treeRect.left);
            line.setAttribute("y2", cRect.top + cRect.height/2 - treeRect.top);
            svgLines.appendChild(line);

            connect(child);
        });
    }
    connect(container.firstElementChild);
}

function render(){
    const highlight = steps[stepIndex]?.nodeVal;
    const treeClone = clone(baseTree);
    applySteps(treeClone);

    container.innerHTML = "";
    container.appendChild(renderNode(treeClone, highlight));

    setTimeout(drawLines, 20);

    const s = steps[stepIndex];
    infoEl.textContent = s.action==="visit"
        ? `Visiting node ${s.nodeVal}`
        : `Swapping children of node ${s.nodeVal}`;

    document.getElementById("prevBtn").disabled = (stepIndex===0);
    document.getElementById("nextBtn").disabled = (stepIndex===steps.length-1);
}

document.getElementById("prevBtn").onclick = ()=>{ stepIndex--; render(); };
document.getElementById("nextBtn").onclick = ()=>{ stepIndex++; render(); };
document.getElementById("runBtn").onclick = ()=>{
    while(stepIndex < steps.length-1) stepIndex++;
    render();
};
document.getElementById("resetBtn").onclick = ()=>{ stepIndex=0; render(); };

render();
})();
</script>

</body>
</html>
