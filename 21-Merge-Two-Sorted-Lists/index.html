<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 21: Merge Two Sorted Lists</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        .node-circle {
            fill: #ffffff;
            stroke-width: 3px;
            transition: all 0.3s ease-out;
            filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
        }
        .node-text {
            font-size: 16px;
            font-weight: 600;
            fill: #1f2937;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }
        .pointer-text {
            font-size: 12px;
            font-weight: 700;
            text-anchor: middle;
            pointer-events: none;
            transition: all 0.3s ease-out;
            text-shadow: 0px 1px 2px white;
        }
        /* Base link style */
        .link-path {
            fill: none;
            stroke: #9ca3af; /* Gray-400 */
            stroke-width: 2px;
            transition: stroke 0.3s;
        }
        /* Specific override for merged links */
        path.link-path.merged {
            stroke: #10b981 !important; /* Emerald-500 */
            stroke-width: 3px;
        }
        /* Specific override for null links */
        path.link-path.null-link {
            stroke: #ef4444 !important; /* Red-500 */
            stroke-dasharray: 4;
        }
        
        #visualization-container {
            position: relative;
            width: 100%;
            max-width: 900px;
            min-height: 450px; 
            margin-top: 20px;
            overflow-x: auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        
        .var-box {
            transition: all 0.3s;
        }
    </style>
</head>
<body>

    <div class="max-w-4xl w-full flex flex-col items-center">
        <h1 class="text-3xl font-bold text-gray-800 mb-2">Merge Two Sorted Lists Visualization</h1>
        <h3 class="text-lg text-gray-600 mb-6">Algorithm: Iterative (using `list1`, `list2`, `curr`, `head` - Java)</h3>

        <!-- Controls -->
        <div class="controls bg-white p-4 sm:p-6 rounded-xl shadow-lg flex flex-wrap gap-4 items-center justify-center border border-gray-100 w-full">
            <div class="flex items-center gap-2">
                <label class="font-semibold text-gray-700">Test Case:</label>
                <select id="test-case-select" class="p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150">
                    <option value="0">Default: L1=[1, 3, 5], L2=[2, 4, 6]</option>
                    <option value="1">L1 shorter: L1=[10], L2=[1, 2, 3]</option>
                    <option value="2">L2 shorter: L1=[1, 2, 3], L2=[10]</option>
                    <option value="3">Empty L1: L1=[], L2=[5, 6]</option>
                    <option value="4">Both empty: L1=[], L2=[]</option>
                </select>
            </div>
            
            <div class="hidden sm:block w-px h-8 bg-gray-200"></div>

            <div class="flex gap-2">
                <button id="btn-prev" class="px-4 py-2 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 transition disabled:bg-gray-400">
                    &larr; Prev
                </button>
                <button id="btn-play" class="px-4 py-2 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 transition disabled:bg-gray-400">
                    Auto Play
                </button>
                <button id="btn-next" class="px-4 py-2 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 transition disabled:bg-gray-400">
                    Next &rarr;
                </button>
                <button id="btn-reset" class="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition">
                    Reset
                </button>
            </div>
        </div>

        <!-- Variable Watcher -->
        <div class="grid grid-cols-4 gap-4 w-full max-w-4xl mt-6">
            <div id="var-list1" class="var-box bg-white p-3 rounded-lg shadow border-l-4 border-indigo-500 flex flex-col items-center">
                <span class="text-xs font-bold text-gray-400 uppercase tracking-wider">list1</span>
                <span class="var-val font-mono text-lg font-bold text-gray-800">NULL</span>
            </div>
            <div id="var-list2" class="var-box bg-white p-3 rounded-lg shadow border-l-4 border-yellow-500 flex flex-col items-center">
                <span class="text-xs font-bold text-gray-400 uppercase tracking-wider">list2</span>
                <span class="var-val font-mono text-lg font-bold text-gray-800">NULL</span>
            </div>
            <div id="var-cur" class="var-box bg-white p-3 rounded-lg shadow border-l-4 border-emerald-500 flex flex-col items-center">
                <span class="text-xs font-bold text-gray-400 uppercase tracking-wider">curr</span>
                <span class="var-val font-mono text-lg font-bold text-gray-800">NULL</span>
            </div>
            <div id="var-head" class="var-box bg-white p-3 rounded-lg shadow border-l-4 border-pink-500 flex flex-col items-center">
                <span class="text-xs font-bold text-gray-400 uppercase tracking-wider">head</span>
                <span class="var-val font-mono text-lg font-bold text-gray-800">NULL</span>
            </div>
        </div>

        <!-- Status Bar -->
        <div id="status-bar" class="w-full max-w-4xl mt-4 p-3 rounded-lg text-center font-mono text-white text-sm shadow-md bg-gray-700 transition-all duration-300">
            <span id="status-text">Ready</span>
        </div>
        
        <!-- Visualization -->
        <div id="visualization-container">
            <svg id="list-svg" width="100%" height="400"></svg>
        </div>
        
        <!-- Code Display -->
        <div class="w-full max-w-4xl mt-6 bg-gray-800 p-4 rounded-xl shadow-xl">
            <pre id="code-display" class="text-gray-200 text-sm overflow-x-auto"></pre>
        </div>
    </div>

<script>
    // --- Configuration ---
    const NODE_RADIUS = 20;
    const NODE_SPACING = 80;
    
    // Y-positions for visualization rows (400px height)
    const Y_LIST_1 = 150; // List 1
    const Y_LIST_2 = 330; // List 2
    const Y_H_NODE = 240; // Dummy Head 'H' node position (Vertically centered between L1 and L2)
    
    // Map data listIndex (1, 2, or 3) to new visual Y position
    const ROW_Y_MAP = { 1: Y_LIST_1, 2: Y_LIST_2 }; // List 3 (Dummy) is handled specially in getNodePos

    const POINTER_OFFSET_TOP = 35; // For List1, List2, Head
    const POINTER_OFFSET_BOTTOM = 35; // For Curr

    const ANIMATION_DURATION = 400; 
    let maxListLength = 0;

    // --- State Management ---
    let snapshots = [];
    let currentStepIndex = 0;
    let autoPlayInterval = null;

    // --- Data Structure ---
    class ListNode {
        constructor(val, id, listIndex, isDummy = false) {
            this.val = val;
            this.id = id;
            this.listIndex = listIndex; // 1, 2, or 3 (Dummy)
            this.visNextId = null; // Pointer to the next node visually
            this.isDummy = isDummy;
        }
    }

    // --- Test Cases ---
    const testCases = [
        { l1: [1, 3, 5], l2: [2, 4, 6] },
        { l1: [10], l2: [1, 2, 3] },
        { l1: [1, 2, 3], l2: [10] },
        { l1: [], l2: [5, 6] },
        { l1: [], l2: [] }
    ];
    
    // --- Logic ---

    function arrayToLists(arr1, arr2) {
        maxListLength = Math.max(arr1.length, arr2.length);

        const nodes = [];
        let list1Head = null;
        let list2Head = null;
        let tempTail = null;

        // Create List 1 Nodes
        arr1.forEach((val, index) => {
            const newNode = new ListNode(val, `node-1-${index}`, 1);
            if (index === 0) { list1Head = newNode; tempTail = newNode; } 
            else { tempTail.visNextId = newNode.id; tempTail = newNode; }
            nodes.push(newNode);
        });

        // Create List 2 Nodes
        tempTail = null;
        arr2.forEach((val, index) => {
            const newNode = new ListNode(val, `node-2-${index}`, 2);
            if (index === 0) { list2Head = newNode; tempTail = newNode; } 
            else { tempTail.visNextId = newNode.id; tempTail = newNode; }
            nodes.push(newNode);
        });

        // Create Dummy Head (List 3)
        const dummyHead = new ListNode('H', 'node-dummy', 3, true);
        nodes.push(dummyHead);

        return { list1Head, list2Head, dummyHead, allNodes: nodes };
    }
    
    function generateSnapshots(arr1, arr2) {
        let history = [];
        
        let { list1Head, list2Head, dummyHead, allNodes } = arrayToLists(arr1, arr2);
        
        // Map for tracking live state
        const allNodesMap = new Map(allNodes.map(n => [n.id, n]));

        // The iterative algorithm state
        let list1 = list1Head;
        let list2 = list2Head;
        let head = dummyHead;
        let curr = dummyHead; // Renamed to curr to match Java code

        const save = (msg, line) => {
            const listData = Array.from(allNodesMap.values()).map(n => ({
                val: n.val,
                id: n.id,
                listIndex: n.listIndex,
                visNextId: n.visNextId,
                isDummy: n.isDummy
            }));

            history.push({
                list: listData,
                list1Id: list1 ? list1.id : null,
                list2Id: list2 ? list2.id : null,
                curId: curr ? curr.id : null, // Uses 'curId' for visualization consistency
                headId: head ? head.id : null,
                // Explicit values for the Variables Panel
                list1Val: list1 ? `Node ${list1.val}` : "NULL",
                list2Val: list2 ? `Node ${list2.val}` : "NULL",
                curVal: curr ? (curr.isDummy ? 'Dummy H' : `Node ${curr.val}`) : "NULL",
                headVal: head ? 'Dummy H' : "NULL",
                message: msg,
                line: line
            });
        };
        
        save(`Initial State. L1: [${arr1.join(', ')}], L2: [${arr2.join(', ')}].`, 3); 

        // Line 3 & 4 (Java): ListNode head = new ListNode(); ListNode curr = head;
        save(`Initialize dummy head and current pointer. head=curr=Dummy Node 'H'.`, 4);
        
        let iteration = 0;
        
        // Line 6 (Java): while (list1 != null && list2 != null)
        while (list1 && list2) {
            iteration++;
            save(`Iteration ${iteration}: Check loop condition (list1 and list2 are non-null).`, 5);

            let chosenNode = null;
            
            // Line 7 (Java): if (list1.val < list2.val)
            if (list1.val < list2.val) {
                // Line 8 (Java): curr.next = list1
                const curNodeInMap = allNodesMap.get(curr.id);
                if (curNodeInMap) curNodeInMap.visNextId = list1.id;
                
                chosenNode = list1;
                list1 = allNodesMap.get(list1.visNextId) || null; // Move list1 pointer

                save(`L1.val (${chosenNode.val}) < L2.val. Attach L1 to curr.next.`, 6);
                
                // Line 9 (Java): list1 = list1.next
                save(`Advance list1 pointer to next node.`, 7);

            } else { // Handles list2.val <= list1.val
                // Line 12 (Java): curr.next = list2
                const curNodeInMap = allNodesMap.get(curr.id);
                if (curNodeInMap) curNodeInMap.visNextId = list2.id;
                
                chosenNode = list2;
                list2 = allNodesMap.get(list2.visNextId) || null; // Move list2 pointer

                save(`L2.val (${chosenNode.val}) <= L1.val. Attach L2 to curr.next.`, 9);
                
                // Line 13 (Java): list2 = list2.next
                save(`Advance list2 pointer to next node.`, 10);
            }
            
            // Line 15 (Java): curr = curr.next
            curr = chosenNode;
            save(`Advance curr pointer to the newly added node.`, 11);
        }

        // Line 18 (Java): curr.next = (list1 != null) ? list1 : list2;
        save(`Loop ended. Check for remaining nodes.`, 13);
        const remaining = list1 || list2;
        if (remaining) {
            const curNodeInMap = allNodesMap.get(curr.id);
            if (curNodeInMap) curNodeInMap.visNextId = remaining.id;
        }
        
        save(`Attach remaining list to curr.next.`, 13);

        // Line 20 (Java): return head.next;
        save(`Return head.next (the start of the merged list). Merging complete.`, 14);
        
        return history;
    }

    // --- D3 Visualization ---

    const svg = d3.select("#list-svg");
    const mainGroup = svg.append("g").attr("id", "main-group");

    // Define Arrowhead markers
    svg.append('defs').html(`
        <marker id="arrow-l1" markerWidth="10" markerHeight="10" refX="19" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L0,10 L10,5 z" fill="#4f46e5" />
        </marker>
        <marker id="arrow-l2" markerWidth="10" markerHeight="10" refX="19" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L0,10 L10,5 z" fill="#f59e0b" />
        </marker>
        <marker id="arrow-merged" markerWidth="10" markerHeight="10" refX="19" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L0,10 L10,5 z" fill="#10b981" />
        </marker>
        <marker id="null-marker" markerWidth="10" markerHeight="10" refX="19" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L0,10 L10,5 z" fill="#ef4444" />
        </marker>
    `);

    // Updated Code Snippet (Java)
    const CODE_SNIPPET = `
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode head = new ListNode();
        ListNode curr = head;

        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                curr.next = list1;
                list1 = list1.next;
            }
            else {
                curr.next = list2;
                list2 = list2.next;
            }
            curr = curr.next;
        }

        curr.next = (list1 != null) ? list1 : list2;

        return head.next;
    }
}
`.trim();

    function renderCode(line) {
        const lines = CODE_SNIPPET.split('\n');
        
        // Mapping of snapshot step line numbers (JS logic) to the 0-indexed line in the trimmed Java snippet
        const lineMap = { 
            3: 3,  // Initial State: Highlight ListNode head/curr init
            4: 3,  // head/curr init
            5: 5,  // while loop start
            6: 6,  // if condition
            7: 7,  // curr.next = list1
            8: 8,  // list1 = list1.next
            9: 11, // curr.next = list2 (inside else)
            10: 12, // list2 = list2.next
            11: 14, // curr = curr.next (outside if/else)
            13: 17, // curr.next = remainder
            14: 19  // return head.next
        };
        const highlightedIndex = lineMap[line];

        const htmlContent = lines.map((l, i) => {
            const isHighlighted = i === highlightedIndex;
            const color = isHighlighted ? 'text-yellow-300 bg-gray-700' : 'text-gray-200';
            return `<div class="transition-all duration-300 ${color} ${isHighlighted ? 'font-semibold' : ''} px-2 rounded-md">${l}</div>`;
        }).join('');

        d3.select("#code-display").html(htmlContent);
    }

    function updateVariables(s) {
        d3.select("#var-list1 .var-val").text(s.list1Val).style("color", s.list1Id !== null ? "#4f46e5" : "#9ca3af");
        d3.select("#var-list2 .var-val").text(s.list2Val).style("color", s.list2Id !== null ? "#f59e0b" : "#9ca3af");
        d3.select("#var-cur .var-val").text(s.curVal).style("color", s.curId !== null ? "#10b981" : "#9ca3af");
        d3.select("#var-head .var-val").text(s.headVal).style("color", s.headId !== null ? "#ec4899" : "#9ca3af");
    }

    function renderList(listData, list1Id, list2Id, curId, headId) {
        mainGroup.selectAll("*").remove(); 
        
        if (listData.length <= 1 && list1Id === null && list2Id === null) {
            mainGroup.append("text").attr("x", "50%").attr("y", "50%")
               .attr("text-anchor", "middle").attr("font-size", "18px")
               .attr("fill", "#6b7280").text("The lists are empty.");
            return;
        }

        const totalNodeSlots = maxListLength + 1; // +1 for the dummy node slot
        const totalWidth = totalNodeSlots * NODE_SPACING;
        const containerWidth = svg.node().getBoundingClientRect().width;
        
        // Define X where the first *content* node (index 0 of L1 or L2) should start.
        const INPUT_LIST_START_X = Math.max(80, (containerWidth / 2) - (totalWidth / 2) + NODE_SPACING);
        svg.attr("width", Math.max(containerWidth, totalWidth + 150));

        // Define the X position for the labels 
        const LABEL_X = INPUT_LIST_START_X - NODE_SPACING - 30;

        // Draw Row Labels
        mainGroup.append("text").attr("x", LABEL_X).attr("y", Y_LIST_1).attr("text-anchor", "end").attr("font-weight", "bold").attr("fill", "#4f46e5").text("List 1");
        mainGroup.append("text").attr("x", LABEL_X).attr("y", Y_LIST_2).attr("text-anchor", "end").attr("font-weight", "bold").attr("fill", "#f59e0b").text("List 2");


        // Helper to get Node Coordinates
        const getNodePos = (id) => {
            const node = listData.find(d => d.id === id);
            if (!node) return null;
            
            let y;
            let x;

            if (node.isDummy) {
                // Dummy Head 'H' is always at the fixed left X and the new middle Y
                y = Y_H_NODE; 
                x = INPUT_LIST_START_X - NODE_SPACING;
            } else {
                // Input list nodes (L1/L2)
                y = ROW_Y_MAP[node.listIndex];
                const indexInRow = parseInt(id.split('-')[2]);
                x = INPUT_LIST_START_X + indexInRow * NODE_SPACING;
            }
            
            return { x, y, node };
        };


        // --- 1. Draw Links ---
        listData.forEach(d => {
            const sourcePos = getNodePos(d.id);
            const targetPos = getNodePos(d.visNextId);
            
            if (sourcePos) {
                // Links originating from the dummy node or curr pointer are "merged" links
                const isMergedLink = d.listIndex === 3 || (d.id === curId); 
                
                if (targetPos) {
                    // Calculate path (can be diagonal)
                    const x1 = sourcePos.x;
                    const y1 = sourcePos.y;
                    const x2 = targetPos.x;
                    const y2 = targetPos.y;

                    // Calculate point where link leaves the source node boundary
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const angle = Math.atan2(dy, dx);
                    const startX_adj = x1 + Math.cos(angle) * NODE_RADIUS;
                    const startY_adj = y1 + Math.sin(angle) * NODE_RADIUS;
                    
                    // Calculate point where link enters the target node boundary (to stop the arrow head correctly)
                    const pad = NODE_RADIUS + 5; 
                    const endX_adj = x2 - Math.cos(angle) * pad;
                    const endY_adj = y2 - Math.sin(angle) * pad;
                    
                    let markerId, linkClass, linkStroke;
                    if (isMergedLink) {
                        markerId = "url(#arrow-merged)";
                        linkClass = "merged";
                        linkStroke = '#10b981';
                    } else if (sourcePos.node.listIndex === 1) {
                        markerId = "url(#arrow-l1)";
                        linkClass = "";
                        linkStroke = '#4f46e5';
                    } else { // listIndex === 2
                        markerId = "url(#arrow-l2)";
                        linkClass = "";
                        linkStroke = '#f59e0b';
                    }

                    mainGroup.append("path")
                        .attr("class", `link-path ${linkClass}`)
                        .attr("stroke", linkStroke)
                        .attr("d", `M ${startX_adj} ${startY_adj} L ${endX_adj} ${endY_adj}`)
                        .attr("marker-end", markerId);

                } else if (d.visNextId === null) {
                    // Null Link (always to the right if it's the end of a chain)
                    const x1 = sourcePos.x + NODE_RADIUS;
                    const x2 = x1 + 40;
                    
                    mainGroup.append("path")
                        .attr("class", `link-path null-link`)
                        .attr("d", `M ${x1} ${sourcePos.y} L ${x2} ${sourcePos.y}`)
                        .attr("marker-end", "url(#null-marker)");

                    mainGroup.append("text")
                        .attr("x", x2 + 10)
                        .attr("y", sourcePos.y + 4)
                        .attr("text-anchor", "start")
                        .attr("font-weight", "bold")
                        .attr("fill", "#ef4444")
                        .attr("font-size", "12px")
                        .text("NULL");
                }
            }
        });

        // --- 2. Draw Nodes ---
        const nodes = mainGroup.selectAll(".list-node")
            .data(listData.filter(d => !d.isDummy), d => d.id); // Draw all non-dummy nodes

        const nodesEnter = nodes.enter().append("g")
            .attr("class", "list-node")
            .attr("transform", d => {
                const pos = getNodePos(d.id);
                return `translate(${pos.x}, ${pos.y})`;
            });

        nodesEnter.append("circle")
            .attr("r", NODE_RADIUS)
            .attr("class", "node-circle")
            .attr("stroke", d => d.listIndex === 1 ? '#4f46e5' : '#f59e0b');

        nodesEnter.append("text")
            .attr("class", "node-text")
            .text(d => d.val);
            
        nodesEnter.transition().duration(ANIMATION_DURATION).style("opacity", 1);
        nodes.exit().remove();
        
        // Draw Dummy Head 
        const dummyNodeData = listData.filter(d => d.isDummy);
        const dummyNodes = mainGroup.selectAll(".dummy-node")
            .data(dummyNodeData, d => d.id);
            
        const dummyEnter = dummyNodes.enter().append("g")
            .attr("class", "dummy-node")
            .attr("transform", d => {
                const pos = getNodePos(d.id);
                return `translate(${pos.x}, ${pos.y})`;
            });

        dummyEnter.append("rect")
            .attr("x", -NODE_RADIUS)
            .attr("y", -NODE_RADIUS)
            .attr("width", NODE_RADIUS * 2)
            .attr("height", NODE_RADIUS * 2)
            .attr("rx", 5)
            .attr("ry", 5)
            .attr("class", "node-circle")
            .attr("stroke", '#ec4899'); // Pink for head/dummy

        dummyEnter.append("text")
            .attr("class", "node-text")
            .text(d => d.val);

        // --- 3. Draw Pointers ---
        const activePointers = [
            { id: list1Id, label: 'list1', color: '#4f46e5', offset: -POINTER_OFFSET_TOP, isBottom: false },
            { id: list2Id, label: 'list2', color: '#f59e0b', offset: -POINTER_OFFSET_TOP, isBottom: false },
            { id: headId, label: 'head', color: '#ec4899', offset: -POINTER_OFFSET_TOP * 1.5, isBottom: false },
            { id: curId, label: 'curr', color: '#10b981', offset: POINTER_OFFSET_BOTTOM, isBottom: true }
        ].filter(p => p.id !== null);

        activePointers.forEach(p => {
            const pos = getNodePos(p.id);
            if (pos) {
                // Adjust for top vs bottom pointers
                const isTop = !p.isBottom;
                
                mainGroup.append("text")
                    .attr("x", pos.x)
                    .attr("y", pos.y + p.offset + (isTop ? 0 : 10))
                    .attr("class", "pointer-text")
                    .attr("fill", p.color)
                    .text(p.label);

                // Small connector line to node
                mainGroup.append("line")
                    .attr("x1", pos.x)
                    .attr("y1", pos.y + p.offset + (isTop ? 5 : -15)) 
                    .attr("x2", pos.x)
                    .attr("y2", isTop ? pos.y - NODE_RADIUS - 3 : pos.y + NODE_RADIUS + 3)
                    .attr("stroke", p.color)
                    .attr("stroke-width", 2);
            }
        });
    }

    // --- Controller Logic ---

    function loadTestCase(index) {
        stopAutoPlay();
        const { l1, l2 } = testCases[index];
        snapshots = generateSnapshots(l1, l2);
        currentStepIndex = 0;
        updateUI();
    }

    function updateUI() {
        if (!snapshots[currentStepIndex]) return;
        const s = snapshots[currentStepIndex];
        
        d3.select("#status-text").text(s.message);
        
        renderList(s.list, s.list1Id, s.list2Id, s.curId, s.headId);
        updateVariables(s);
        renderCode(s.line);

        document.getElementById("btn-prev").disabled = currentStepIndex === 0;
        document.getElementById("btn-next").disabled = currentStepIndex === snapshots.length - 1;
        
        if (currentStepIndex === snapshots.length - 1) {
            d3.select("#status-bar").style('background-color', '#10b981');
        } else {
            d3.select("#status-bar").style('background-color', '#374151');
        }
    }

    function nextStep() {
        if (currentStepIndex < snapshots.length - 1) {
            currentStepIndex++;
            updateUI();
        } else {
            stopAutoPlay();
        }
    }

    function prevStep() {
        if (currentStepIndex > 0) {
            currentStepIndex--;
            updateUI();
        }
    }

    function toggleAutoPlay() {
        if (autoPlayInterval) {
            stopAutoPlay();
        } else {
            document.getElementById("btn-play").textContent = "Pause";
            if (currentStepIndex === snapshots.length - 1) {
                currentStepIndex = 0;
                updateUI();
            }
            autoPlayInterval = setInterval(nextStep, ANIMATION_DURATION + 300);
        }
    }

    function stopAutoPlay() {
        clearInterval(autoPlayInterval);
        autoPlayInterval = null;
        document.getElementById("btn-play").textContent = "Auto Play";
    }

    document.getElementById("test-case-select").addEventListener("change", (e) => loadTestCase(e.target.value));
    document.getElementById("btn-next").addEventListener("click", () => { stopAutoPlay(); nextStep(); });
    document.getElementById("btn-prev").addEventListener("click", () => { stopAutoPlay(); prevStep(); });
    document.getElementById("btn-reset").addEventListener("click", () => { stopAutoPlay(); currentStepIndex = 0; updateUI(); });
    document.getElementById("btn-play").addEventListener("click", toggleAutoPlay);

    loadTestCase(0);
</script>
</body>
</html>
